t.index
valid.classfcn = as.numeric(valid.Phwin >= .5)
mean(valid.classfcn)
for (i in 1:n){
bin.index = t.index[,i]
perf[i] = mean(valid.classfcn[bin.index] == outcome.validn[bin.index])
}
perf = c()
for (i in 1:n){
bin.index = t.index[,i]
perf[i] = mean(valid.classfcn[bin.index] == outcome.validn[bin.index])
}
perf
n = 10
cutpoints = seq(0,1, length = n+1)
p = rep(NA, n)
outcome.validn = hWin[validn.index]
t.index = matrix(rep(NA), nrow = sum(validn.index), ncol = n)
for (i in 1:n){
t.index[,i] = valid.Phwin > cutpoints[i] & valid.Phwin < cutpoints[i+1]
}
colnames(t.index) = paste('bin', 1:n, sep = '')
# t.index is a matrix with each row corresponding to
# a logical index of the bin of each validn prediction
perf = c()
for (i in 1:n){
bin.index = t.index[,i]
perf[i] = mean(valid.classfcn[bin.index] == outcome.validn[bin.index])
}
plot(perf)
perf
t.index = matrix(rep(NA), nrow = sum(validn.index), ncol = n)
bin.range = c()
for (i in 1:n){
t.index[,i] = valid.Phwin > cutpoints[i] & valid.Phwin < cutpoints[i+1]
bin.range[i] = paste(cutpoints[i], 'to', cutpoints[i+1], sep = '')
}
bin.range
bin.range = c()
for (i in 1:n){
t.index[,i] = valid.Phwin > cutpoints[i] & valid.Phwin < cutpoints[i+1]
bin.range[i] = paste(cutpoints[i], ' - ', cutpoints[i+1], sep = '')
}
bin.range
rbind(bin.range, perf)
rbind(bin.range, round(perf, 3))
bin.low = c()
counts = c()
for (i in 1:n){
t.index[,i] = valid.Phwin > cutpoints[i] & valid.Phwin < cutpoints[i+1]
bin.low[i] = cutpoints[i]
counts[i] = sum(t.index[,i])
}
perf = c()
for (i in 1:n){
bin.index = t.index[,i]
perf[i] = mean(valid.classfcn[bin.index] == outcome.validn[bin.index])
}
rbind(bin.low, counts, round(perf, 3))
rbind(bin.low, round(counts, 0), round(perf, 3))
cbind(bin.low, round(counts, 0), round(perf, 3))
cbind(bin.low, 'count' = round(counts, 0), round(perf, 3))
cbind(bin.low, 'count' = round(counts, 0), 'perf' = round(perf, 3))
n = 5
cutpoints = seq(0,1, length = n+1)
p = rep(NA, n)
outcome.validn = hWin[validn.index]
t.index = matrix(rep(NA), nrow = sum(validn.index), ncol = n)
bin.low = c()
counts = c()
for (i in 1:n){
t.index[,i] = valid.Phwin > cutpoints[i] & valid.Phwin < cutpoints[i+1]
bin.low[i] = cutpoints[i]
counts[i] = sum(t.index[,i])
}
colnames(t.index) = paste('bin', 1:n, sep = '')
# t.index is a matrix with each row corresponding to
# a logical index of the bin of each validn prediction
perf = c()
for (i in 1:n){
bin.index = t.index[,i]
perf[i] = mean(valid.classfcn[bin.index] == outcome.validn[bin.index])
}
cbind(bin.low, 'count' = round(counts, 0), 'perf' = round(perf, 3))
cutpoints = c(0, .25, .45, .55, .75, 1)
p = rep(NA, n)
outcome.validn = hWin[validn.index]
t.index = matrix(rep(NA), nrow = sum(validn.index), ncol = n)
bin.low = c()
counts = c()
for (i in 1:n){
t.index[,i] = valid.Phwin > cutpoints[i] & valid.Phwin < cutpoints[i+1]
bin.low[i] = cutpoints[i]
counts[i] = sum(t.index[,i])
}
colnames(t.index) = paste('bin', 1:n, sep = '')
# t.index is a matrix with each row corresponding to
# a logical index of the bin of each validn prediction
perf = c()
for (i in 1:n){
bin.index = t.index[,i]
perf[i] = mean(valid.classfcn[bin.index] == outcome.validn[bin.index])
}
cbind(bin.low, 'count' = round(counts, 0), 'perf' = round(perf, 3))
n = 3
d = .07
cutpoints = c(0, .5 - d, .5 + d , 1)
p = rep(NA, n)
outcome.validn = hWin[validn.index]
t.index = matrix(rep(NA), nrow = sum(validn.index), ncol = n)
bin.low = c()
counts = c()
for (i in 1:n){
t.index[,i] = valid.Phwin > cutpoints[i] & valid.Phwin < cutpoints[i+1]
bin.low[i] = cutpoints[i]
counts[i] = sum(t.index[,i])
}
colnames(t.index) = paste('bin', 1:n, sep = '')
# t.index is a matrix with each row corresponding to
# a logical index of the bin of each validn prediction
perf = c()
for (i in 1:n){
bin.index = t.index[,i]
perf[i] = mean(valid.classfcn[bin.index] == outcome.validn[bin.index])
}
cbind(bin.low, 'count' = round(counts, 0), 'perf' = round(perf, 3))
model.perf = cbind(bin.low, 'count' = round(counts, 0), 'perf' = round(perf, 3))
model.stat = (count[1]*perf[1] + count[3]*perf[3])/num.pred
num.pred = sum(counts[c(1,3)])
model.stat = (counts[1]*perf[1] + counts[3]*perf[3])/num.pred
model.stat
make.win.pct.table = function(week, season, dat){
# a function that takes the week and season and returns a table with
# each team's winning percentage through the previous week of the season,
# but only for teams that play in the given week and season
which.season = season
which.week = week
teams.playing = c(as.character(dat$V[dat$SEAS == which.season
& dat$WEEK == which.week]),
as.character(dat$H[dat$SEAS == which.season
& dat$WEEK == which.week]))
hMargin = dat$PTS.H - dat$PTS.V
hWin = hMargin > 0
winner = ifelse(hWin, as.character(H), as.character(V))
table.index = SEAS == which.season & WEEK < which.week
winner.table = winner[table.index]
newdat = dat[table.index,]
team.win.pcts = data.frame(team = c(), win.pct = c())
for (t in 1:length(unique(dat$V))){
team.name = as.character(unique(newdat$V)[t])
if (is.element(team.name, teams.playing)){
num.games = sum(newdat$V == team.name | newdat$H == team.name)
num.wins = sum(winner.table == team.name)
win.pct = num.wins/num.games
team.win.pcts[t,1] = team.name
team.win.pcts[t,2] = round(win.pct, 4)
}
}
return(team.win.pcts)
}
make.MM = function(data, outcome, index){
MM = data.frame(hWin = c(), hStr = c(), vStr = c(), h = c(), v = c(), seas = c(), wk = c())
MM.dat = data[index,]
y = outcome[index]
s.prev = 0; w.prev = 0
for (i in 1:nrow(MM.dat)){
s = MM.dat$SEAS[i]
w = MM.dat$WEEK[i]
if (!((s == s.prev) & (w == w.prev))){
win.pcts = make.win.pct.table(w, s, dat)
}
home.team = as.character(MM.dat$H[i])
away.team = as.character(MM.dat$V[i])
home.strength = win.pcts[which(win.pcts[,1] == home.team), 2]
away.strength = win.pcts[which(win.pcts[,1] == away.team), 2]
MM[i, 1] = y[i]
MM[i, 2] = home.strength
MM[i, 3] = away.strength
MM[i, 4] = home.team
MM[i, 5] = away.team
MM[i, 6] = s
MM[i, 7] = w
s.prev = s
w.prev = w
}
names(MM) = c('homeW', 'hStrength', 'vStrength', 'h', 'v', 'seas', 'week')
MM$homeW = factor(as.numeric(MM$homeW))
return(MM)
}
allGames = read.csv("gameindex.csv", T, ",")
allGames = read.csv("gameindex.csv", T, ",")
hMargin = allGames$PTS.H - allGames$PTS.V
hWin = hMargin > 0
training.seasons = 2000:2006
training.weeks = 6:15
training.index = is.element(SEAS, training.seasons) & is.element(WEEK, training.weeks)
hMargin = allGames$PTS.H - allGames$PTS.V
hWin = hMargin > 0
MM = make.MM(allGames, hWin, training.index)
make.win.pct.table = function(week, season, dat){
# a function that takes the week and season and returns a table with
# each team's winning percentage through the previous week of the season,
# but only for teams that play in the given week and season
which.season = season
which.week = week
teams.playing = c(as.character(dat$V[dat$SEAS == which.season
& dat$WEEK == which.week]),
as.character(dat$H[dat$SEAS == which.season
& dat$WEEK == which.week]))
hMargin = dat$PTS.H - dat$PTS.V
hWin = hMargin > 0
winner = ifelse(hWin, as.character(H), as.character(V))
table.index = SEAS == which.season & WEEK < which.week
winner.table = winner[table.index]
newdat = dat[table.index,]
team.win.pcts = data.frame(team = c(), win.pct = c())
for (t in 1:length(unique(dat$V))){
team.name = as.character(unique(newdat$V)[t])
if (is.element(team.name, teams.playing)){
num.games = sum(newdat$V == team.name | newdat$H == team.name)
num.wins = sum(winner.table == team.name)
win.pct = num.wins/num.games
team.win.pcts[t,1] = team.name
team.win.pcts[t,2] = round(win.pct, 4)
}
}
return(team.win.pcts)
}
make.MM = function(data, outcome, index){
MM = data.frame(hWin = c(), hStr = c(), vStr = c(), h = c(), v = c(), seas = c(), wk = c())
MM.dat = data[index,]
y = outcome[index]
s.prev = 0; w.prev = 0
for (i in 1:nrow(MM.dat)){
s = MM.dat$SEAS[i]
w = MM.dat$WEEK[i]
if (!((s == s.prev) & (w == w.prev))){
win.pcts = make.win.pct.table(w, s, data)
}
home.team = as.character(MM.dat$H[i])
away.team = as.character(MM.dat$V[i])
home.strength = win.pcts[which(win.pcts[,1] == home.team), 2]
away.strength = win.pcts[which(win.pcts[,1] == away.team), 2]
MM[i, 1] = y[i]
MM[i, 2] = home.strength
MM[i, 3] = away.strength
MM[i, 4] = home.team
MM[i, 5] = away.team
MM[i, 6] = s
MM[i, 7] = w
s.prev = s
w.prev = w
}
names(MM) = c('homeW', 'hStrength', 'vStrength', 'h', 'v', 'seas', 'week')
MM$homeW = factor(as.numeric(MM$homeW))
return(MM)
}
MM = make.MM(allGames, hWin, training.index)
require(boot)
fit1 = glm(homeW ~ hStrength + vStrength, data = MM, family = binomial(link = 'probit'))
fit1Pred = ifelse(fit1$fitted>=.5, 1, 0)
pct.diff = fit1$fitted - (as.numeric(MM$homeW)-1)
validn.seasons = 2007:2009
validn.weeks = 6:15
validn.index = is.element(SEAS, validn.seasons) & is.element(WEEK, validn.weeks)
MM.validn = make.MM(allGames, hWin, validn.index)
valid.Phwin = predict.glm(fit1, MM.validn, type = 'response')
valid.classfcn = as.numeric(valid.Phwin >= .5)
n = 3
d = .07
cutpoints = c(0, .5 - d, .5 + d , 1)
p = rep(NA, n)
outcome.validn = hWin[validn.index]
t.index = matrix(rep(NA), nrow = sum(validn.index), ncol = n)
bin.low = c()
counts = c()
for (i in 1:n){
t.index[,i] = valid.Phwin > cutpoints[i] & valid.Phwin < cutpoints[i+1]
bin.low[i] = cutpoints[i]
counts[i] = sum(t.index[,i])
}
colnames(t.index) = paste('bin', 1:n, sep = '')
# t.index is a matrix with each row corresponding to
# a logical index of the bin of each validn prediction
perf = c()
for (i in 1:n){
bin.index = t.index[,i]
perf[i] = mean(valid.classfcn[bin.index] == outcome.validn[bin.index])
}
model.perf = cbind(bin.low, 'count' = round(counts, 0), 'perf' = round(perf, 3))
num.pred = sum(counts[c(1,3)])
model.statistic = (counts[1]*perf[1] + counts[3]*perf[3])/num.pred
model.statistic
list('apple' = c(1,2,3), 'car' = 'a')
get.model.statistic = function(data, outcome, index, fit, numbins, delta){
MM.validn = make.MM(data, outcome, .index)
valid.Phwin = predict.glm(fit, MM.validn, type = 'response')
valid.classfcn = as.numeric(valid.Phwin >= .5)
## can optimize this for d
n = numbins
d = delta
cutpoints = c(0, .5 - d, .5 + d , 1)
p = rep(NA, n)
outcome.validn = hWin[index]
t.index = matrix(rep(NA), nrow = sum(index), ncol = n)
bin.low = c()
counts = c()
perf = c()
for (i in 1:n){
bin.index = valid.Phwin > cutpoints[i] & valid.Phwin < cutpoints[i+1]
bin.low[i] = cutpoints[i]
counts[i] = sum(t.index[,i])
perf[i] = mean(valid.classfcn[bin.index] == outcome.validn[bin.index])
}
model.perf = cbind(bin.low, 'count' = round(counts, 0), 'perf' = round(perf, 3))
model.statistic = (counts[1]*perf[1] + counts[3]*perf[3])/sum(counts[c(1,3)])
out = list('T' = round(model.statistic, 4), 'table' = model.perf)
return(out)
}
get.model.statistic(allGames, hWin, validn.index, fit, 3, .07)
get.model.statistic = function(data, outcome, index, fit, numbins, delta){
MM.validn = make.MM(data, outcome, index)
valid.Phwin = predict.glm(fit, MM.validn, type = 'response')
valid.classfcn = as.numeric(valid.Phwin >= .5)
## can optimize this for d
n = numbins
d = delta
cutpoints = c(0, .5 - d, .5 + d , 1)
p = rep(NA, n)
outcome.validn = hWin[index]
t.index = matrix(rep(NA), nrow = sum(index), ncol = n)
bin.low = c()
counts = c()
perf = c()
for (i in 1:n){
bin.index = valid.Phwin > cutpoints[i] & valid.Phwin < cutpoints[i+1]
bin.low[i] = cutpoints[i]
counts[i] = sum(t.index[,i])
perf[i] = mean(valid.classfcn[bin.index] == outcome.validn[bin.index])
}
model.perf = cbind(bin.low, 'count' = round(counts, 0), 'perf' = round(perf, 3))
model.statistic = (counts[1]*perf[1] + counts[3]*perf[3])/sum(counts[c(1,3)])
out = list('T' = round(model.statistic, 4), 'table' = model.perf)
return(out)
}
get.model.statistic(allGames, hWin, validn.index, fit, 3, .07)
get.model.statistic(allGames, hWin, validn.index, fit1, 3, .07)
get.model.statistic = function(data, outcome, index, fit, numbins, delta){
MM.validn = make.MM(data, outcome, index)
valid.Phwin = predict.glm(fit, MM.validn, type = 'response')
valid.classfcn = as.numeric(valid.Phwin >= .5)
n = numbins
d = delta
cutpoints = c(0, .5 - d, .5 + d , 1)
p = rep(NA, n)
outcome.validn = hWin[index]
t.index = matrix(rep(NA), nrow = sum(index), ncol = n)
bin.low = c()
counts = c()
perf = c()
for (i in 1:n){
bin.index = valid.Phwin > cutpoints[i] & valid.Phwin < cutpoints[i+1]
bin.low[i] = cutpoints[i]
counts[i] = sum(t.index[i])
perf[i] = mean(valid.classfcn[bin.index] == outcome.validn[bin.index])
}
model.perf = cbind(bin.low, 'count' = round(counts, 0), 'perf' = round(perf, 4))
model.statistic = (counts[1]*perf[1] + counts[3]*perf[3])/sum(counts[c(1,3)])
out = list('T' = round(model.statistic, 4), 'table' = model.perf)
return(out)
}
get.model.statistic(allGames, hWin, validn.index, fit1, 3, .07)
make.win.pct.table = function(week, season, dat){
# a function that takes the week and season and returns a table with
# each team's winning percentage through the previous week of the season,
# but only for teams that play in the given week and season
which.season = season
which.week = week
teams.playing = c(as.character(dat$V[dat$SEAS == which.season
& dat$WEEK == which.week]),
as.character(dat$H[dat$SEAS == which.season
& dat$WEEK == which.week]))
hMargin = dat$PTS.H - dat$PTS.V
hWin = hMargin > 0
winner = ifelse(hWin, as.character(H), as.character(V))
table.index = SEAS == which.season & WEEK < which.week
winner.table = winner[table.index]
newdat = dat[table.index,]
team.win.pcts = data.frame(team = c(), win.pct = c())
for (t in 1:length(unique(dat$V))){
team.name = as.character(unique(newdat$V)[t])
if (is.element(team.name, teams.playing)){
num.games = sum(newdat$V == team.name | newdat$H == team.name)
num.wins = sum(winner.table == team.name)
win.pct = num.wins/num.games
team.win.pcts[t,1] = team.name
team.win.pcts[t,2] = round(win.pct, 4)
}
}
return(team.win.pcts)
}
make.MM = function(data, outcome, index){
MM = data.frame(hWin = c(), hStr = c(), vStr = c(), h = c(), v = c(), seas = c(), wk = c())
MM.dat = data[index,]
y = outcome[index]
s.prev = 0; w.prev = 0
for (i in 1:nrow(MM.dat)){
s = MM.dat$SEAS[i]
w = MM.dat$WEEK[i]
if (!((s == s.prev) & (w == w.prev))){
win.pcts = make.win.pct.table(w, s, data)
}
home.team = as.character(MM.dat$H[i])
away.team = as.character(MM.dat$V[i])
home.strength = win.pcts[which(win.pcts[,1] == home.team), 2]
away.strength = win.pcts[which(win.pcts[,1] == away.team), 2]
MM[i, 1] = y[i]
MM[i, 2] = home.strength
MM[i, 3] = away.strength
MM[i, 4] = home.team
MM[i, 5] = away.team
MM[i, 6] = s
MM[i, 7] = w
s.prev = s
w.prev = w
}
names(MM) = c('homeW', 'hStrength', 'vStrength', 'h', 'v', 'seas', 'week')
MM$homeW = factor(as.numeric(MM$homeW))
return(MM)
}
get.model.statistic = function(data, outcome, index, fit, numbins, delta){
MM.validn = make.MM(data, outcome, index)
valid.Phwin = predict.glm(fit, MM.validn, type = 'response')
valid.classfcn = as.numeric(valid.Phwin >= .5)
n = numbins
d = delta
cutpoints = c(0, .5 - d, .5 + d , 1)
p = rep(NA, n)
outcome.validn = hWin[index]
t.index = matrix(rep(NA), nrow = sum(index), ncol = n)
bin.low = c()
counts = c()
perf = c()
for (i in 1:n){
bin.index = valid.Phwin > cutpoints[i] & valid.Phwin < cutpoints[i+1]
bin.low[i] = cutpoints[i]
counts[i] = sum(bin.index)
perf[i] = mean(valid.classfcn[bin.index] == outcome.validn[bin.index])
}
model.perf = cbind(bin.low, 'count' = round(counts, 0), 'perf' = round(perf, 4))
model.statistic = (counts[1]*perf[1] + counts[3]*perf[3])/sum(counts[c(1,3)])
out = list('T' = round(model.statistic, 4), 'table' = model.perf)
return(out)
}
get.model.statistic(allGames, hWin, validn.index, fit1, 3, .07)
names(fit1)
fit1$aic
>glm
?glm
fit1$y
fit1$converged
a = read.table('Game.2012.csv')
a = read.csv('Game.2012.csv')
col.names(a)
colnames(a)
b = read.csv('TeamGame.2012.csv')
colnames(b)
colnames(a)
colnames(b)
gsub('Opponent(.*)', '\\1', colnames(b))
gsub('Opponent(.*)', '\\1', colnames(b)[grep('$Opponent', colnames(b))])
grep('$Opponent', colnames(b))
?grep
grep('^Opponent', colnames(b))
gsub('Opponent(.*)', '\\1', colnames(b)[grep('^Opponent', colnames(b))])
colnames(a)[(1:78)*2]
colnames(a)
gsub('Home(.*)', '\\1', colnames(a)[grep('^Home', colnames(b))])
gsub('Home(.*)', '\\1', colnames(a)[grep('^Home', colnames(a))])
gsub('Opponent(.*)', '\\1', colnames(b)[grep('^Opponent', colnames(b))])
game = gsub('Opponent(.*)', '\\1', colnames(b)[grep('^Opponent', colnames(b))])
team.game = gsub('Home(.*)', '\\1', colnames(a)[grep('^Home', colnames(a))])
?is.element
is.element(game, team.game)
game(is.element(game, team.game))
game[is.element(game, team.game)]
game[!is.element(game, team.game)]
team.game
game[!is.element(game, team.game)]
game
a
colnames(a)
a[1,27]
game[!is.element(game, team.game)]
colnames(b)
a = read.csv('Game.2012.csv')
b = read.csv('TeamGame.2012.csv')
b[,1:10]
b[,1:4]
b[,1:5]
85to11data = read.csv('./85 to 11 data/TeamSeason.1985-2011.csv')
setwd('./85 to 11 data')
setwd('~/projects/nfl stuffs/nfl/85 to 11 data/')
getwd()
85to11data = read.csv('TeamSeason.1985-2011.csv')
85to11data = read.csv('TeamSeason.19852011.csv')
?read.csv
85to11data = read.csv(file = 'TeamSeason.1985-2011.csv')
allData = read.csv(file = paste(dataLoc,'TeamSeason.1985-2011.csv'))
dataLoc = '~projects/nfl stuffs/nfl/85 to 11 data/'
allData = read.csv(file = paste(dataLoc,'TeamSeason.1985-2011.csv'))
allData = read.csv(file = paste(dataLoc,'TeamSeason.1985-2011.csv', sep = ''))
